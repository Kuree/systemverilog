# VPI and DPI
Although SystemVerilog offers a set of powerful language primitives to satisfy normal usages, in many cases people wish to opt for more direct control over the simulation, retrospection on the design hierarchy at runtime, or even have finer granularity of assertion. As a result, in 2005 IEEE standardize the interface between the simulator and the C programming interface and name it Verilog Procedural Interface (VPI), originally known as PLI 2.0. VPI allows C functions to be invoked in behavioral RTL code and provides a set of events to which C code can register callback. Notice that VPI is part of Verilog standard and by virtually inheriting Verilog, SystemVerilog also supports VPI.

Although a powerful tool to use, VPI has couple limitations and SystemVerilog introduces Direct Programming INterface (DPI), which allows foreign languages such as C and C++ to directly interface with the simulator. Unlike VPI, DPI ensures compatibility and efficiency by providing an two separated layers (SystemVerilog layer and foreign language layer). We will discuss the similarity and differences in this chapter.


## Verilog Procedural Interface
VPI offers a set of C functions that can be used to interact with the simulator:

1. Introspect the entire design hierarchy
2. Set callbacks to a set of simulation events such as when the simulation starts or when a signal value changes
3. Wrap a C function as used-defined system task called by test bench code.

In this chapter we will mainly focus on the first two features of VPI, since the last feature can be done in DPI most of the time.


### Design Introspection
In VPI, every object is referred as a `handle`, which has the data type of `vpiHandle` defined in the header file. This is essentially a pointer to an object whose implementation is vendor-dependent. Therefore, we cannot make any assumptions about how the handle is created or managed except following the LRM rules, if we want our code to be portable to various simulators.

The data model for VPI is centered around the actual design hierarchy, originated from the very top module. As a result, there are essentially two kinds of relationship for VPI handles:

1. One-to-one. For instance, the module instance handle has one-to-one relationship to its module definition handle.
2. One-to-many. This is more common, for instance, a module instance typically has many port instances.

Depends on the relationship, the API call to query related objects is different. Although in most cases the relationship is intuitive, we highly recommend to check the LRM for correctness. Figure @fig:instance-diagram shows an example of the data model for the instance and how you can traverse the object handles with different relationships and obtain other information.


![Instance model diagram. Copied from LRM 37.10](images/09/instance-diagram.svg){#fig:instance-diagram}

The diagram packs a dense information and we need to read it in several aspects. First, we can take a look at how to obtain object handle information. There are three VPI functions that allows us introspect properties of an object handle, namely `vpi_get`, `vpi_get64`, and `vpi_get_str`. Their function definitions are shown below:


```C
XXTERN PLI_INT32  vpi_get             PROTO_PARAMS((PLI_INT32 property,
                                                    vpiHandle object));
XXTERN PLI_INT64  vpi_get64           PROTO_PARAMS((PLI_INT32 property,
                                                    vpiHandle object));
XXTERN PLI_BYTE8 *vpi_get_str         PROTO_PARAMS((PLI_INT32 property,
                                                    vpiHandle object));
```

`PLI_INT32` is a `typedef` defined in the header file, which implies that value has to be predefined as well. As a result, you should call `vpi_get` with a predefined property and you will result back with a predefined value as well. `vpi_get_str` is used to get string properties from the object handle, such as names. Figure @fig:vpi-get-diagram below shows a more detailed example of how they can be used with respect to the relation diagram.

![Diagram key for accessing properties. Copied from LRM 37.4.2](images/09/vpi-get-diagram.svg){#fig:vpi-get-diagram}

Now let's look at how to traverse the hierarchy based on different relations. If it is an one-to-one relationship, use `vpi_handle`, and if it's one-to-many relationship, use `vpi_iterate` followed by `vpi_scan`. Figure @fig:relationship-diagram below shows how one should interpret the relationship arrows in the diagram. Notice that in the figure, the LRM distinguish between object and tag. This is because the VPI has a set of predefined object types and tags are not object types.

![Diagram key for traversing relationships. Copied from LRM 37.4.3](images/09/relationship-diagram.svg){#fig:relationship-diagram}

Now let's take a look at the instance diagram again now that we have covered the properties and relationship. The bottom left section describes properties associated with the instance object and their corresponding types, categorized by their functionalities. For instance, suppose we have a handle `vh` for a module instance, we can use `vpi_get_str(vpiName, vh)` to get the instance name, or `vpi_get_str(vpiFullName, vh)` for its full name.

To query its internal variable, we can use `vpiReg` as shown below:

```C
vpiHandle iter, obj;
iter = vpi_iterate(vpiReg, vh);
while (obj = vpi_scan(iter)) {
    // do something with obj
}
```

Notice the backward arrow from the right to left, it means that we can query the parent with one-to-one relation using `vpiInstance` and `vpiModule` respectively.

Below is a more detailed example how we can print out the entire design hierarchy using VPI with breadth-first search. Notice that we're using C++ instead of C. Notice that by convention, if we query `vpiModule` with an `nullptr`, we will get the top module instance.

```C++
std::queue<vpiHandle> handle_queues;
handle_queues.emplace(nullptr);

while (!handle_queues.empty()) {
    auto *mod_handle = handle_queues.front();
    handle_queues.pop();
    auto *handle_iter = vpi_->vpi_iterate(vpiModule, mod_handle);
    // if the instance doesn't have any child instances, this will be nullptr
    if (!handle_iter) continue;
    vpiHandle child_handle;

    while ((child_handle = vpi_->vpi_scan(handle_iter)) != nullptr) {
        // get the definition name
        const auto *def_name = vpi_->vpi_get_str(vpiDefName, child_handle);
        // get the child instance handle's name
        auto const *hierarchy_name = vpi_->vpi_get_str(vpiFullName, child_handle);
        // print out the information
        printf("Instance name: %s (%s)", hierarchy_name, def_name);
        
        handle_queues.emplace(child_handle);
    }
}
```

### Callbacks


## Direct Programming Interface

