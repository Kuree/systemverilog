# Simulation and Test Benches
A significant portion of the language are dedicated to test benches and testing. In this chapter we will cover some commonly used techniques to write efficient test bench for your hardware designs.

## How SystemVerilog Simulator Works
Before we delve into details of how to write a proper test bench, we need to establish a deep understanding of how simulator works and how it schedules events. This will help us troubleshoot bugs and errors in the future.

A specification-compliant SystemVerilog simulator follows a discrete event execution model, where the simulation time advances with value updates. The hardware design is inherently parallel, where processes such as `always_comb` and `always_ff` are executed currently. Each time the value of a net/variable changes, we will have an *update event* and any processes that are sensitive to that event need to be evaluated as well, which is called *evaluation event*. At each "timestamp", the simulator needs to first compute the update events, evaluate update events, and loop back to see if there is more update events triggered by previous update events.

The term for "timestamp" in SystemVerilog is *simulation time*. It can be transformed back to real time using the `timescale` compiler directive introduced earlier in the book. We use simulation time, or simply time throughout the entire chapter to avoid confusion.

Although the design and test bench is parallel by nature, most simulators are single-threaded and follows certain rules to evaluate the code to ensure it is conceptually correct. Typically the simulator divides the unit time slop into multiple regions where events can be scheduled in a pre-defined orders. In each region, the events can be scheduled arbitrarily, allowing simulator performs optimization when it sees fit. Figure @fig:sim_diagram shows how the time slot is divided into different regions and the execution flow between different regions.

![Event scheduling regions. Image taken from SystemVerilog LRM Figure4-1](images/06/sim-diagram.svg){#fig:sim_diagram}

PLI regions will be discussed in much details later in the book. For now it is enough to know there are regions reserved for third-party libraries that can be loaded into the simulator and can have direct access to the simulator state.

Fully cover each region requires much lengthy details and readers are encouraged to read through the language LRM and even try to implement a simple interpreter-based simulator. We will focus on three major regions: active event region, inactive events region, and NBA events region.



## Timing Controls
Timing is one of the most important factor to consider when writing a test bench. Should the signal be stable before the clock edge, or how long should the signal be valid for? What does delay mean? This section will cover various aspect of timing controls.


## Fork and Join

## How to Avoid Race Conditions
