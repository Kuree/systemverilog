# Types, Operator, and Expressions
Like ordinary software programming languages, SystemVerilog allows designers manipulate different types and data objects when modeling the hardware. Although bears much similarity to languages such as C/C++ (in fact SystemVerilog is influenced by them), SystemVerilog is a language to model hardware, which has different semantics than software programming models. This chapter explores the type system and associated operators in SystemVerilog.

## Data Types
SystemVerilog uses the terminology of data type and data objects to distinguish between objects and its data type. As specified in the language specification, a data type is a set of values and a set of operations that can be performed on those values. A data object is a named entity that has a data value and a data type associated with it.

### 4-State Values
One major distinction between SystemVerilog and other software programming languages is that the value set in SystemVerilog consists of the following four basic values:
 - **0**: represents a logic zero or false condition
 - **1**: represents a logic one or true condition
 - **x**: represents an unknown value
 - **z**: represents a high-impedance state.

Values 0 and 1 serve the same purpose as in languages such as C/C++, but x and z are hardware specific. High-impedance value z typically implies a physically disconnected state, i.e. an infinitely high resistance. It commonly appears in designs where a pin used as a bi-directional bus, e.g. tri-state. Unknown value x means the system is able to determine the value, which may happen in various condition. One common situation for x to appear in simulation is usage of uninitialized memory cells. Another common scenario is low-power designs where some part of circuit is "shut-down", i.e. no supply voltage. Any signal coming out from the shut-down region will be x. Keep in mind that x can propagate through your circuit if not taken care of, since any logic operation on unknown values results in unknown values. We will discuss briefly how to take care of x later in the book.

Data types that only use **0** or **1** have 2-state values.

### Basic data types
`logic` is the most commonly used basic data types in SystemVerilog. `logic` signal has 4-state values. It can either represent a combinational signal or a sequential signal, since the downstream tools such simulator and synthesis tools will determine whether to instantiate a flip-flop based on the usage. A rule of thumb is that any signals in your synthesizable design should be declared as `logic` (a few exceptions apply, which will be discussed). This is to ensure that the simulator and synthesis tool agree with each other, avoiding critical bugs that can only been discovered through gate-level simulation or even post-silicon tests. For instance, if a signal is declared as 2-state value, the simulator will happily compute with 0 and 1s. However, since the actual silicon has z and x values, we will see a discrepancy after the synthesis, which leads to a potential bug.

By default, a signal declared as `logic` only has one bit value. To declare a multi-bit signal, we can do `logic[15:0] a`, which declares a 16-bit signal. Notice that we can also do `logic[0:15] a`. The difference is bit-ordering, similar to endianness for byte-ordering. Typically bit-ordering follows the same endianness as the byte order. It is highly recommend to use a consist bit-ordering throughout the design to avoid potential bugs. In this book we will use big-endian and `high:low` bit-ordering.

By default, every declared variable is unsigned. To declare a signed variable, use `signed` keyword such as `logic signed [15:0] a`. Although SystemVerilog allows you to mix signed variable with unsigned, similar to C/C++, it leaves a potential bug that cannot be caught by the compiler (some tools may produce a warning), we shall never mix signed and unsigned arithmetics and any assumption about the how the automatic conversion work is grounded for future errors that is difficult to debug.

To declare an array, we can add extra dimension to the "left", such as `logic[3:0][15:0] a`, which declares 4 16-bit logics. We can adding arbitrary more dimensions as well. The array created by such approached is called packed array. To access the first 16-bit `logic`, we can do `a[0]`. Notice that we can also slice out a sub-array, such as `a[1:0]`, which gives as the first two values.

Notice that we can also do `logic[15:0] a[3:0]`, which is called unpacked array. Although unpacked array has advantage over packed array such as giving simulator more flexibility to allocate arrays since they do not need to be contiguous, because of that, we cannot slice a sub-array, nor can we bulk assign values. Again, choosing which representation depends on the project style, as long as it is consistent throughout the entire project. In this book we will use packed array.

#### 2-state Variables
SystemVerilog also defines 2-state types, typically used for test benches or functional models that are more high-level. Unlike C, these data types has pre-defined widths, as show in Table @tbl:2-state-data-type.

|   Type   | Bit width |
|:--------:|:---------:|
|    bit   |     1     |
|   byte   |     8     |
| shortint |     16    |
|    int   |     32    |
|  longint |     64    |
Table: 2-state data types in SystemVerilog. All types are signed by default. Keyword `unsigned` is needed to make it unsigned. {#tbl:2-state-data-type}

### Enumeration
SystemVerilog defines enumerations as a set of integral named constants, similar to that of C/C++. Enumeration need to be declared with a type with the default type be `int`. Since `int` is unwelcoming in synthesizable RTL, we shall always use `logic` data types.
An example of enumeration is shown below:
```SystemVerilog
enum logic[1:0] { STATE1, STATE2, STATE3 } state;
// later on
state = STATE1;
```

Here are some rules regarding the name and integral values of enumeration:

1. Values in enum can be integers and increment from an initial value of 0. This, however, can be overridden, as shown below. In this case, `STATE2` will be 2 and `STATE3` will be 3.
   ```SystemVerilog
   enum logic[1:0] {STATE1 = 1, STATE2, STATE3 } state;
   ```
2. Both the enumeration names and their integer values shall be unique. This can be combined with the first rule.
3. The integer values in enumerate will be casted to their corresponding type. An overflow will be treated as an error
   ```SystemVerilog
   enum logic[1:0] {STATE = 4} state; // this will result in an error
   ```
4. Enumeration are strongly typed. Although directly assigning integer to enumerate variables will trigger an automatic cast, we highly recommend to use explicit cast.

There are several helper functions with enumerated types:

1. `first()`: returns the value of the first member of the enumeration.
   ```SystemVerilog
   enum logic[1:0] { STATE1, STATE2, STATE3 } state;
   // later on
   state = state.first(); // assigns STATE1 to state
   ```
2. `last()`: returns the value of the last member of the enumeration.
3. `next(int unsigned N = 1)`: returns `N`th next enumeration stating from the current value.
   ```SystemVerilog
   enum logic[1:0] { STATE1, STATE2, STATE3 } state;
   // later on
   state = state.first(); // assigns STATE1 to state
   state = state.next(); // assigns STATE2 to state
   ```
4. `prev(int unsigned N = 1)`: returns `N`th previous enumeration value starting from the current value.

Notice that `next()` and `prev()` are type-safe ways to increment enumeration values, which is highly recommend to use compared to simply addition followed by mod.


### User-Defined Types
Like C, SystemVerilog allows user-defined types (UDT).

### Struct


### Non-Synthesizable Data Types
When modeling high-level

#### Other Data Types
There are other data types in SystemVerilog we have not covered so far, such as `event` and `chandle`. We will cover `chandle` later in DPI.

### Type Casting
