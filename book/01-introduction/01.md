# Introduction
SystemVerilog is a hardware description language (HDL) to model, simulate, and verify electronic systems. It is standardized as IEEE-1800 with latest revision in 2017. This chapter will cover its history, provide some simply example to get started, and conclude with the scope of this book. At the end of this chapter you should understand why SystemVerilog is the *de facto standard* for modern hardware systems design and verification and how this book can help you learn SystemVerilog.

## A brief history of SystemVerilog
SystemVerilog is the ultimate combination following language designs as well as other technologies donation such as BlueSpec:

1. Verilog, which is an IEEE standard (IEEE 1364);
2. Superlog, donated to Accellebra from the statup company Co-Design Automation (acquired by Synopsys);
3. OpenVera, donated by Synopsys.

Before we delve into the history of SystemVerilog, we need to take a step back and appreciate the evolution of Verilog, SystemVerilog's precursor. Verilog was original develop between 1983 and 1984 and the company that created the language was eventually bought by Cadence in 1990. About 10 years later, Verilog is transferred by Cadence into the public domain and latter submitted to IEEE and becomes IEEE 1364-1995 standard, commonly referred as Verilog-95.

As Verilog gained much popularity, significantly improvement had been made into Verilog-95, leading to a newer version of the standard, IEEE 1364-2001, known as Verilog-2001. Lots of syntax enhancement made the language simpler and more expressive.

IEEE 1364-2005 is the last version of Verilog, where minor improvements were made into the standard. This standard marks the end of Verilog and was later merged into SystemVerilog and became a subset of SystemVerilog in IEEE 1800-2009.

One common misconception is that Verilog is the HDL that is synthesizable, that is, able to be synthesized by the synthesis tools, and SystemVerilog is a verification language not synthesizable. This is completely wrong as Verilog is a strict subset of SystemVerilog and only a subset of SystemVerilog is synthesizable. The confusion got worse when the IEEE 1364-2005 (Verilog) merged with IEEE 1800-2005 (SystemVerilog) and the name "Verilog" ceased to exist in IEEE's nomenclature. We will use SystemVerilog throughout the book, but you may hear people use Verilog when referring to SystemVerilog.

With the donation from Superlog, SystemVerilog gains advanced syntax to boost design productivity, such as `struct` and `enum`, which itself is heavily influenced by C/C++. OpenVera greatly enhanced SystemVerilog's ability to express assertion under various conditions, easing simulation coverage collection and formal verification.

Asides from the unification of these three languages, SystemVerilog also introduce the concept of object-oriented-programming (OOP), which is influenced by C++ and Java. Unfortunately, design code that uses OOP cannot be synthesized for all synthesis tools, yet it is still commonly used in verification.

First standardized in 2005 as IEEE 1800-2005, SystemVerilog enjoys a new and refined standard every 4-5 years. IEEE 1800-2009 marked the maturity of SystemVerilog as it merges in Verilog and integrates with Verilog-AMS. It also ensures interoperability with other HDLs such as SystemC and VHDL. Two subsequent revision standard IEEE 1800-2012 and IEEE 1800-2017 further refined and clarified the language specification.

In introspect, the entire digital system design community witnessed the trend where a number of proprietary design languages fight for market and the only winners are the one that open up their specification. Remaining open allows EDA vendors as well as designers voice their critiques and concerns during the standardization process, which lead to wider adoption. There was a significant amount of concern in early 2010s where designers were uncertain whether SystemVerilog would ever be

## Getting started
SystemVerilog files are text-based and end mostly in `.sv` for implementation and `.svh` for header and definition files. Some EDA tools, e.g. Verilator, can parse SystemVerilog from normal Verilog file extension (`.v`), but most tools will report syntax error and a special flag needed to inform their internal language parser. In this book we will use `.sv` and `.svh` for file extensions.

We will use the simple hello world example to help you get started. Save the following code as `example1.sv`.
```SystemVerilog
module example1;

initial begin
    $display("hello world");
end

endmodule
```

To run it, simply do
```bash
$ xrun example1.sv
```

You will see the following output along with other compilation information in the console output.
```
xcelium> run
hello world
```

### A note on EDA tools used in the book
By default, the book assumes you have the following commercial EDA tools installed:

1. Xcelium, which provides `xrun` command.
2. JasperGold, which provides `jaspergold` command.

While we understand that accessing these tools is difficult for most people, given their absurd license cost, these tools are selected due to their support for SystemVerilog features covered in this book. If you only have access to VCS, you should be able to run all the code examples by translating the simulator flags appropriately.

If you do not have access to any commercial EDA tools, you can use [EDA Playground](https://www.edaplayground.com/) for free. Notice that you have to register an account and accept its limited use terms. Most of the design and simulation code used here can be run on EDA Playground. Unfortunately EDA Playground does not have JasperGold installed.

That being said, if you really need to use FOSS software, here is a list of tools that might work with the code examples below. However, we will not cover any command in this book, nor will we offer workaround to run the tools in case things do work.

1. [iverilog](http://iverilog.icarus.com/)
2. [Verilator](https://www.veripool.org/wiki/verilator)
3. [yosys](http://www.clifford.at/yosys/). Notice that you need to purchase a Verific licence so that yosys can parse SystemVerilog files. The default SystemVerilog in yosys is very limited.

## What will this book cover
SystemVerilog by no means is a complex language and the IEEE 1800-2017 standard spans more than a thousand pages. This book mainly focus on the following aspects of SystemVerilog for digital system design and the EDA tool-chains associated with it:

1. Design technique for digital systems synthesis. The book will first cover comprehensive SystemVerilog language features for synthesis and how they can be used to model hardware. It will focus on vender and technology independent modeling techniques, which can be applied to both ASIC and FPGA design. How to use ASIC/FPGA synthesis tools, however, is beyond the scope of discussion.
2. RTL simulation. This book will gradually transit from simple test bench to object-oriented and reusable test bench design.
3. Software co-verification. This book will cover Verilog Procedural Interface (VPI) and Direct Programming Interface (DPI) in details and how they can be used to offer functional models for verification as well as perform other useful tasks.
4. SystemVerilog Assertions (SVAs). This book will discuss various usages in details and how can SVAs be used in traditional simulation for coverage reports, and serve a foundation for formal verification.

We hope by the end of book you will be confident in writing SystemVerilog for digital system design and verification.