# Control Flow, Modules, and Interfaces
## Modules
Modules are the basic building blocks of SystemVerilog. It is intended to be a reusable component
that can be connected to form a larger component. To declare a module, we can use the following syntax:
```SystemVerilog
module module_name;
// content of the module
endmodule
```
Notice that due to legacy reason, there is no namespace for modules. As a result, `module_name` has to be unique in your entire design. To declare the ports for the module, we can simply do

```SystemVerilog
module module_name (input  logic      clk,
                    input  logic      rst_n,
                    input  logic[7:0] in,
                    output logic[7:0] out);

// content of the module
endmodule
```

Keywords `input` and `output` are used to specify the direction of ports. There is another keyword, `inout` which makes the port bidirectional. `inout` is typically used for tri-state designs and we will not cover it in the book. If you are declaring multiple ports sharing the same port direction and types, you can omit the subsequential ones, as shown below. Notice that the code is equivalent. It is up to the designers to choose which style they want to follow. In this book we will use the more verbose version.

```SystemVerilog
module module_name (input  logic      clk, rst_n,
                    input  logic[7:0] in,
                    output logic[7:0] out);
endmodule
```


The type for the ports can be any integral values, such as logic, arrays, or struct. It can also be interface, which will be covered later in the chapter.

Notice that there is another style of declaring port, which is specifying port names first, then later on declare the port direction and types, typically called Non-ANSI style. This style is out-dated and we do not recommend use it in practice.

To declare variables inside the module, we can simply put definition inside the `module endmodule`.

```SystemVerilog
module ex1 (input  logic      clk,
            input  logic      rst_n,
            input  logic[7:0] in,
            output logic[7:0] out);

logic [7:0] value; 

endmodule
```

In the example code we declare 8-bit value `value`. Notice that it is highly recommended to declare the variable type before using the variable. Although implicit logic declaration is supported in SystemVerilog, it is dangerous and usually triggers compiler warnings/errors.

### Module Parameters
SystemVerilog allows the module definition parametrized by certain values, which makes the modules more reusable. For instance, suppose we have an ALU module parametrized by the data width, we can reuse the same definition for both 32-bit and 64-bit ALU instantiation.

To declare a parametrized module, we can use the following syntax, which is also the ANSI style.

```SystemVerilog
module mod_param
    #(parameter int              WIDTH=8,
      parameter logic[7:0]       VALUE='h0)
     (input     logic            clk,
      input     logic            rst_n,
      input     logic[WIDTH-1:0] in,
      output    logic[WIDTH-1:0] out);

endmodule
```

In the example above, module `mod_param` is parametrized by two parameters `WIDTH` and `VALUE`. We immediately use `WIDTH` to parametrize the bit-width of `in` and `out`. Notice that we also specify the data type for `VALUE`. In general we recommend to specify the data type of a parameter. If it used for data width parametrization, `int` should suffice. In the example we also give the parameters a default value, which is highly recommended to do so.

There is another type of "parameter" called `localparam`. It is not parameterization per se, since its value cannot be changed through instantiation. However, for the sake of completeness we will cover it here. Local parameters are typically used for storing magic numbers. For state values, however, you should use `enum` instead.

```SystemVerilog
module localparam_ex;

localparam logic[31:0] VALUE = 32'd42;

endmodule
```

In the example above we define a magic number `VALUE` to have the value of 42. We can later use `VALUE` whenever we need its value.

### Module Instantiation and Hierarchy
Once we have a module definition, we can instantiate it in a parent module. Suppose we have a module definition as follows:

```SystemVerilog
module child (input  logic clk,
              input  logic in,
              output logic out);

endmodule
```

We can instantiate the child module as follows:

```SystemVerilog
module parent;

// declare variables to connect to the child
logic clk;
logic in;
logic out;

// instantiate a child
child child_inst (
    .clk(clk),
    .in(in),
    .out(out)
);

endmodule
```

In the example above, we first declares three variables, `clk`, `in`, `out`, which will be wired to our child instance. To instantiate the child module, we create an instance called `child_inst`. To specify the port wiring, we use `.child_port_name(parent_var_name)` syntax. It means to wire `parent_var_name` from the parent module to `child_port_name` port from the child instance.

There is another short-hand to instantiate the child module in our case. Since the `child_port_name` is identical to `parent_var_name`, we can do the following

```SystemVerilog
child child_inst (.*);
```

`(.*)` tells the compiler to automatically find and wire matching variable from the parent module. You can even override the default matching with extra connections, as shown below, which wires `clk_in` to `child_inst`'s `clk` and leaves the rest to the default matching.

```SystemVerilog
logic clk_in;

child child_inst (.clk(clk_in), .*);
```

Although it may simplify the code and make it more readable, because the matching only relies on the name, it may be matched to an unexpected wire. We recommend to only use this style when the design is simple.

To instantiate a module with different parameter values other than the default ones, we can do the following, using the module `mod_param` defined earlier.

```SystemVerilog
module parent;

logic clk;
logic rst_n;
logic [15:0] in;
logic [15:0] out;

mod_param #(.WIDTH(16)) child_inst (
    .clk(clk),
    .rst_n(rst_n),
    .in(in),
    .out(out)
);

endmodule
```

In the example above we override the parameter value `WIDTH` with 16. Notice that we have to manually change the bit-width of `in` and `out`. A better way to do is the following, where the bit-width is only specified by a single parameter in the parent scope.:

```SystemVerilog
module parent;

localparam int WIDTH = 16;

logic clk;
logic rst_n;
logic [WIDTH-1:0] in;
logic [WIDTH-1:0] out;

mod_param #(.WIDTH(WIDTH)) child_inst (
    .clk(clk),
    .rst_n(rst_n),
    .in(in),
    .out(out)
);

endmodule
```

To access variables through hierarchy, we can do `child_inst.out` from the parent module. We only recommend to do so in test bench, in instead of RTL code for synthesis.

A design style where all the logic are specified through module instantiation rather than the procedural blocks is called *structural* Verilog. Unless you are very experienced in RTL design or have a particular need in physical design, we highly recommend not to use such style in RTL design. It will reduce the synthesis quality and make verification more difficult. We will discuss the benefit of another style, *behavioral* Verilog, where design logics are specified through procedural blocks.

## Continuous Assignment
Continuous assignment wires the values on the right hand side to the left side. *Continuous* in its name implies that whenever an operand in the right-hand expression changes, the whole right-hand side expression shall be evaluated and its result will be assigned to the left hand side. This is used to model combinational circuit where the output of the circuit updates its value whenever the input values change.

To use continuous assignment, we can do

```SystemVerilog
module continuous_assign;
logic [3:0] a;
logic [3:0] b;

assign a = b;
endmodule
```

You can of course use more complex expression such as

```SystemVerilog
logic c;
assign a = c? b : b + 1;
```

There are couple rules apply to continuous assignments:

1. Continuous assignment can only appear in the scope of a module, that is, its lexical parent should be `module`. You cannot declare a continuous assignment in other scopes such as procedural blocks or functions, which we will cover shortly.
2. Each bit of left hand side can only be assigned to once as continuous assignments. For instance, it is illegal to do something below, where bit `a[1]` is assigned twice.
   ```SystemVerilog
   assign a[1:0] = b[1:0];
   assign a[1] = c;
   ```
3. The left hand can only be a net/variable, or a select of a vector/net, or a concatenation. For the case of concatenation, the operator can be seen as "unpacked" in the concatenation order, as shown below, where the sum of `a`, `b`, and `cin` is split into `cout` and `sum`. Since `cout` is only 1-bit, it gets the value of carry out.
    ```SystemVerilog
    // a 4-bit adder with carry
    logic [3:0] a;
    logic [3:0] b;
    logic [3:0] sum;
    logic       cin;
    logic       cout;

    assign {cout, sum} = a + b + cin;
    ```
## Scope Rules
