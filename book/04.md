# Common Design Practices
The end goal of RTL design, especially for ASIC, is to produce smallest and fastest circuit possible. To do so, we need to understand how synthesis tools analyze and optimize the design. In addition, we are also concerned about the simulation speed, since waiting tests to run is effectively wasting engineering efforts. Although synthesis and simulation tools have numerous optimization passes and transformations, one important factor for the end result is the design pattern, i.e., do the code follow the tool's design guide. Lots of optimization are tuned for a particular design pattern, making the code easier to to be understood and thus simplified by the tools. In addition, some design patterns may simplify the code structures and make the code more readable and reusable.

In this chapter we will go through some common design practices and how we should program the logic and structure the source code.

## Compiler Directives and Packages
Similar to C/C++, SystemVerilog defines a preprocessing stage where macros are expanded in the original source code. The compiler directives are not turing-complete and less versatile than that of C/C++,meaning even fix-bounded recursive computation is difficult to be specified in SystemVerilog. Nevertheless, it allows some level of preprocessing in SystemVerilog.


### Compiler Directives
There are several compiler directives defined by the language. We will cover some of the most used macros here:

1. `` `__FILE__``
2. `` `__LINE__``
3. `` `define``
4. `` `else``
5. `` `elseif``
6. `` `ifdef``
7. `` `ifndef``
8. `` `endif``
8. `` `undef``
10. `` `timescale``
11. `` `include``

`` `__FILE__`` and `` `__LINE__`` are used the same way as `__FILE__` and `__LINE__` in C/C++. Users can use that for test bench debugging. During preprocessing, these two compiler directives will be replaced with the actually file name and line number.

`` `define`` allows you to define macros, which can be used later in the code. We will show two examples where the first one defines values, and the second one define function-like code snippets, which takes arguments. Notice that unlike C/C++, macros have to be prefixed with `` ` `` when used in code.

```SystemVerilog
`define VALUE 10

module top (input logic clk);

logic [31:0] a;

always_ff @(posedge clk)
    a <= `VALUE;

endmodule
```

In the example above, we define `` `VALUE`` to be 10, and used it as register value. Even though we cover the usage here, please avoid defining constant values as macros in such way. It is because:

1. It is difficult to find where the macro is defined, e.g. either from a file or command line options
2. There is no namespace regarding macro values. If there are two macros shares the same name, whichever gets parsed later will be used. This may cause unexpected bugs that is difficult to debug, since the compiler may not issue warning for macro re-definition.

We highly recommend to use define constants in a package, which will be covered later in this chapter.

Another way to use `` `define`` is to define some code snippets which can be re-used later, as shown in the example below (also in `code/04/macros_arguments.sv`):

```SystemVerilog
`define REGISTER(NAME, WIDTH, VALUE, CLK) \
    logic [WIDTH-1:0] NAME;               \
    always_ff @(posedge CLK) begin        \
        NAME <= VALUE;                    \
    end

module top;

logic        clk;
logic [15:0] in;

// declare 3 registers that are pipelined to signal in, in sequence
`REGISTER(reg1, 16, in,   clk)
`REGISTER(reg2, 16, reg1, clk)
`REGISTER(reg3, 16, reg2, clk)

// set the clock to 0 at time = 0, then tick the clock every 2 unit of time
initial clk = 0;
always clk = #2 ~clk;

initial begin
    for (int i = 0; i < 3; i++) begin
        in = i;
        // wait for a cycle
        #4;
        // print out the register value
        $display("reg1: %d reg2: %d reg3: %d", reg1, reg2, reg3);
    end
    $finish;
end

endmodule
```

We will see the expected output, where `x` denotes uninitialized register value:
```
reg1:     0 reg2:     x reg3:     x
reg1:     1 reg2:     0 reg3:     x
reg1:     2 reg2:     1 reg3:     0
```

In the code example above, we first define three registers that are pipelined to signal `in` (in chained fashion). The macro `REGISTER` first defines the register given `NAME` and `WIDTH`, then it instantiate an `always_ff` block and assign the `VALUE` to the register as every clock cycle. Notice that we have to use `\` for multi-line definitions.

Although sometimes using a macro may save time and make the code more reusable, it is important to find a balance between repetitive code segments and macro usage. Keep in mind that macro is substituted during preprocessing stage, it will make source-code level debugging challenging. You also need to be careful about macro re-definition since all the macros are in global namespace.

During the macro definition, sometimes you need to undefine some macro names for a different usage. Similar to C/C++, you can use `` `undef`` to un-define the macro.

`` `ifdef`` and `` `ifndef`` can be used to test whether certain macro has been defined (or not defined). You need to close the compiler directives with `` `endif``. You can also add `` `else`` and`` `elseif`` to account for different scenarios. Notice that for a header file, they can be used together with `` `define`` to provide an include guard, which allows the header file to be included in multiple places. Their usages are identical to those of C/C++, so we will not cover them here.

`` `timescale`` is an important compiler directive useful to simulators. It specifies the unit of measurement for time and precision of time in specific design elements. There can be only be at most *one* timescale defined for any compilation-unit scope. In other words, it is illegal to define timescales at two different source files compiled together. The syntax for `` `timescale`` is shown below:

```SystemVerilog
// general syntax
`timescale time_unit / time_precision
// e.g.
`timescale 1ns / 1ps
`timescale 1ns / 1ns
```

The `time_unit` argument specifies the unit of measurement time and delays, and the `time_precision` argument specifies how delay values are rounded before used in simulation. `time_precision` should be at least as precise as `time_unit`, since `time_precision` is used for finer precision of simulation. The unit of `time_unit` and `time_precision` can be `s`, `ms`, `us`, `ns`, `ps`, and `fs`. The integer part specifies an order of magnitude for the size of the value, in other words, the only valid number is `1`, `10`, and `100`.

Timescale is crucial to simulate jittering and timing violation. It is also required for any power-related analysis. It is highly recommend to include timescale in your top-level test bench, even though it is not used.

`` `include`` serves the same purpose as `#include` in C/C++, where it includes definitions from another file. It's highly recommended to provide an include guard to the include file. If the filename is enclosed in quotes, e.g. `` `include "filename.svh"``, the compiler will first search its current working directory, and then search any user-specified locations. If the filename is enclosed in angle brackets, e.g. `` `include <filename.svh>``, the filename has to be files defined by language standard. This rule is similar to that of C/C++.

### Packages
Although `` `include`` provides a way for designers to share definitions, the compiler directives essentially asks the compiler to copy the content of included file into the source file, which is a legacy feature influenced by C. As modern programming languages start to use modules/packages to structure the source code, e.g. module in C++20, SystemVerilog introduce a construct called `package` that allows 
designers to reuse definitions, interfaces, and functions. Since `package` is synthesizable, it is highly recommend to use it in both RTL and test benches. Here is an example of package:

```SystemVerilog
package my_def_pkg;

// local parameters
localparam VALUE = 42;

// struct
typedef struct {
    logic a;
    logic b;
} my_struct_t;

// enum
typedef enum logic { RED, GREEN } color_t;

// function
function logic and_op(logic a, logic b);
    return a & b;
endfunction

endpackage: my_def_pkg
```

Here is an incomplete list of constructs that are allowed inside a package:

1. parameter declaration, e.g. `parameter` and `localparam`
2. function declaration, e.g. automatic function
3. data declaration, e.g., struct and enum
4. DPI import and export
5. class declaration
6. package import declaration

Since `parameter` cannot be redefined in side a package, we highly recommend to use `localparam` in lieu of `parameter` since they are functionally identical in a `package`. In other words, `localparam` does not have the visibility restriction in a `package`.

#### Package Import

To use the package definition in other modules, we need to use `import` keyword to import definition. There are several ways to import contents of a package and we will cover two commonly used approaches here:

1. wildcard import. This is similar to Python's `from pkg_name import *`:
   ```SystemVerilog
   import my_def_pkg::*;
   ```
2. explicit import. This is similar to Python's `from pkg_name import class_name`:
   ```SystemVerilog
   import my_def_pkg::my_struct_t;
   ```

After importing, the identifiers (i.e. struct names or enum value names) can be used directly in the module. One thing to notice that there are several places where we can put package import. Depends on where the content of the package is used, there are two standard approaches to do so:

1. If the identifier is used for module port definition, the import needs to placed before port list:
   ```SystemVerilog
   module top
       import my_def_pkg::*;
       (input my_struct_t in);
    endmodule: top
   ```
2. Otherwise, we shall put the import inside the module:
   ```SystemVerilog
   module top;
       import my_def_pkg::*;
       my_struct_t a;
   endmodule: top
   ```

#### Import Packages within a Package
Like software programming languages, you can import a package content inside another package, and the "chained" imports can be visible to the consumer. Here is an example (`code/04/chained_packages.sv`) illustrates the package imports:

```SystemVerilog
package def1_pkg;
    typedef enum logic[1:0] {ADD, SUB, MULT, DIV} alu_opcode_t;
endpackage: def1_pkg

package def2_pkg;
    // import alu_opcode_t from def1_pkg
    import def1_pkg::alu_opcode_t;
    // define a new struct that include alu_opcode_t
    typedef struct {
        alu_opcode_t alu_opcode;
        logic[7:0] addr;
    } opcode_t;
endpackage: def2_pkg

module top;
    // alu_opcode_t is NOT accessible from def2_pkg
    // the next line is ILLEGAL
    // import def2_pkg::alu_opcode_t;
    import def2_pkg::*;

    opcode_t opcode;

endmodule: top
```

Notice unlike some software programming language such as Python, where the imported identifier is accessible as part of the new package, SystemVerilog prohibits such behavior. If you try to import `alu_opcode_t` from `def2_pkg`, you will get a recursive import error in the compiler.

#### Package Usage Caveats
Since the content of a package is scoped, when use wildcard import, there is a chance of naming conflict. A rule of thumb is that when a naming conflicts, always resort to explicit import. Some coding styles prohibit the usage of wildcard import, which make the code a little bit more verbose, but more readable and maintainable. The exact scoping rule is beyond of scope of this book, but interested user should refer to Table 26-1 in 1800-2017.

Another caveat is that packages have to be compiled before any module files that rely on them. One systematic way is to rely on build tools such as `make` to ensure the order of compilation. Another simple way to do is to put packages before other sources while supplying file names to the tools.
