# Common Design Practices
The end goal of RTL design, especially for ASIC, is to produce smallest and fastest circuit possible. To do so, we need to understand how synthesis tools analyze and optimize the design. In addition, we are also concerned about the simulation speed, since waiting tests to run is effectively wasting engineering efforts. Although synthesis and simulation tools have numerous optimization passes and transformations, one important factor for the end result is the design pattern, i.e., do the code follow the tool's design guide. Lots of optimization are tuned for a particular design pattern, making the code easier to to be understood and thus simplified by the tools. In addition, some design patterns may simplify the code structures and make the code more readable and reusable.

In this chapter we will go through some common design practices and how we should program the logic and structure the source code.

## Compiler Directives and Packages
Similar to C/C++, SystemVerilog defines a preprocessing stage where macros are expanded in the original source code. The compiler directives are not turing-complete and less versatile than that of C/C++,meaning even fix-bounded recursive computation is difficult to be specified in SystemVerilog. Nevertheless, it allows some level of preprocessing in SystemVerilog.


### Compiler Directives
There are several compiler directives defined by the language. We will cover some of the most used macros here:

1. `` `__FILE__``
2. `` `__LINE__``
3. `` `define``
4. `` `else``
5. `` `elseif``
6. `` `ifdef``
7. `` `ifndef``
8. `` `endif``
8. `` `undef``
10. `` `timescale``
11. `` `include``

`` `__FILE__`` and `` `__LINE__`` are used the same way as `__FILE__` and `__LINE__` in C/C++. Users can use that for test bench debugging. During preprocessing, these two compiler directives will be replaced with the actually file name and line number.

`` `define`` allows you to define macros, which can be used later in the code. We will show two examples where the first one defines values, and the second one define function-like code snippets, which takes arguments. Notice that unlike C/C++, macros have to be prefixed with `` ` `` when used in code.

```SystemVerilog
`define VALUE 10

module top (input logic clk);

logic [31:0] a;

always_ff @(posedge clk)
    a <= `VALUE;

endmodule
```

In the example above, we define `` `VALUE`` to be 10, and used it as register value. Even though we cover the usage here, please avoid defining constant values as macros in such way. It is because:

1. It is difficult to find where the macro is defined, e.g. either from a file or command line options
2. There is no namespace regarding macro values. If there are two macros shares the same name, whichever gets parsed later will be used. This may cause unexpected bugs that is difficult to debug, since the compiler may not issue warning for macro re-definition.

We highly recommend to use define constants in a package, which will be covered later in this chapter.

Another way to use `` `define`` is to define some code snippets which can be re-used later, as shown in the example below (also in `code/04/macros_arguments.sv`):

```SystemVerilog
`define REGISTER(NAME, WIDTH, VALUE, CLK) \
    logic [WIDTH-1:0] NAME;               \
    always_ff @(posedge CLK) begin        \
        NAME <= VALUE;                    \
    end

module top;

logic        clk;
logic [15:0] in;

// declare 3 registers that are pipelined to signal in, in sequence
`REGISTER(reg1, 16, in,   clk)
`REGISTER(reg2, 16, reg1, clk)
`REGISTER(reg3, 16, reg2, clk)

// set the clock to 0 at time = 0, then tick the clock every 2 unit of time
initial clk = 0;
always clk = #2 ~clk;

initial begin
    for (int i = 0; i < 3; i++) begin
        in = i;
        // wait for a cycle
        #4;
        // print out the register value
        $display("reg1: %d reg2: %d reg3: %d", reg1, reg2, reg3);
    end
    $finish;
end

endmodule
```

We will see the expected output, where `x` denotes uninitialized register value:
```
reg1:     0 reg2:     x reg3:     x
reg1:     1 reg2:     0 reg3:     x
reg1:     2 reg2:     1 reg3:     0
```

In the code example above, we first define three registers that are pipelined to signal `in` (in chained fashion). The macro `REGISTER` first defines the register given `NAME` and `WIDTH`, then it instantiate an `always_ff` block and assign the `VALUE` to the register as every clock cycle. Notice that we have to use `\` for multi-line definitions.

Although sometimes using a macro may save time and make the code more reusable, it is important to find a balance between repetitive code segments and macro usage. Keep in mind that macro is substituted during preprocessing stage, it will make source-code level debugging challenging. You also need to be careful about macro re-definition since all the macros are in global namespace.

During the macro definition, sometimes you need to undefine some macro names for a different usage. Similar to C/C++, you can use `` `undef`` to un-define the macro.

`` `ifdef`` and `` `ifndef`` can be used to test whether certain macro has been defined (or not defined). You need to close the compiler directives with `` `endif``. You can also add `` `else`` and`` `elseif`` to account for different scenarios. Notice that for a header file, they can be used together with `` `define`` to provide an include guard, which allows the header file to be included in multiple places. Their usages are identical to those of C/C++, so we will not cover them here.

`` `timescale`` is an important compiler directive useful to simulators. It specifies the unit of measurement for time and precision of time in specific design elements. There can be only be at most *one* timescale defined for any compilation-unit scope. In other words, it is illegal to define timescales at two different source files compiled together. The syntax for `` `timescale`` is shown below:

```SystemVerilog
// general syntax
`timescale time_unit / time_precision
// e.g.
`timescale 1ns / 1ps
`timescale 1ns / 1ns
```

The `time_unit` argument specifies the unit of measurement time and delays, and the `time_precision` argument specifies how delay values are rounded before used in simulation. `time_precision` should be at least as precise as `time_unit`, since `time_precision` is used for finer precision of simulation. The unit of `time_unit` and `time_precision` can be `s`, `ms`, `us`, `ns`, `ps`, and `fs`. The integer part specifies an order of magnitude for the size of the value, in other words, the only valid number is `1`, `10`, and `100`.

Timescale is crucial to simulate jittering and timing violation. It is also required for any power-related analysis. It is highly recommend to include timescale in your top-level test bench, even though it is not used.

`` `include`` serves the same purpose as `#include` in C/C++, where it includes definitions from another file. It's highly recommended to provide an include guard to the include file. If the filename is enclosed in quotes, e.g. `` `include "filename.svh"``, the compiler will first search its current working directory, and then search any user-specified locations. If the filename is enclosed in angle brackets, e.g. `` `include <filename.svh>``, the filename has to be files defined by language standard. This rule is similar to that of C/C++.
