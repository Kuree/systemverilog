# Class and Object-Oriented Programming
One of the biggest features introduced in SystemVerilog is the ability to write functional model in an object-oriented manner, i.e. using the `class` construct. Although `class` construct is not synthesizable unfortunately, `class` provides a more software-oriented approach to model hardware behavior for verification. SystemVerilog supports the following object-oriented programming (OOP) practice:
- Inheritance
- Polymorphism

In addition to the normal OOP, SystemVerilog also allows type parametrization for the class (similar to templates in C++)

## Class Definition and Syntax
The syntax of class is similar to that of C++. The constructor is called `new` and unfortunately there is no function overloading. However, similar to Python, users can provide default arguments to allow different usage. Here is a simple example of `class`:

```SystemVerilog
class Node;
    Node next;

    // constructor
    function new();
        next = null;
    endfunction

endclass
```

Notice that like Java/Python, each instance of the object in SystemVerilog is a "reference" and there is no pointer type. Keyword `null` is used to denoted null reference. You will get null exceptions when you try to access members of a null object. We can enhance the `Node` constructor with default argument in such way that users can also pass in the next reference while constructing the object:

```SystemVerilog
function new(Node next_node=null);
    next = next_node;
endfunction
```

By default, every member declared in the class is public, meaning any code can modify the attributes or call the functions regardless of the scope. To add private access modifier, we can use `local` keyword. For instance, we can have:

```SystemVerilog
class Node;
    local Node next;

    function new(Node next_node=null);
        next = next_node;
    endfunction

    // local function
    local function foo();
    endfunction
endclass
```

To instantiate the object, we can use `new` keyword, similar to Java/C#. To access member attributes or function, we can either use their identifiers directly or use `this` keyword to avoid naming conflicts, similar to that of C++. Here is a complete example of single-linked-list that has proper access modifier:

```SystemVerilog
class Node;
    local Node next;

    function new(Node next_node=null);
        next = next_node;
    endfunction

    // local function
    local function foo();
    endfunction
endclass

class List;
    local Node head_;

    function new();
        head_ = null;
    endfunction

    function Node head();
        return head_;
    endfunction

    function void add_node();
        automatic Node new_node;
        new_node = new(head_);
        // use "this" to access member attributes
        this.head_ = new_node;
    endfunction

endclass
```

Object in SystemVerilog is managed by the simulator runtime and thus garbage-collected, similar to Java/C#. As a result of that, we may also see performance downgrade when garbage collection hurts our simulation flow. As premature optimization is the root of all evil, we should be careful about optimization on memory allocation during verification.

You can also have static methods in the class, using the keyword `static`, e.g. `static function string name();`. `static` function follows the same semantics as normal function, e.g. their scope and lifetime. As a result, `automatic` keyword is required in some cases.

## Class Inheritance
SystemVerilog allows class inheritance and polymorphism via inheritance. Although the semantics are similar to other software programming languages, there are some nuance difference that creates somme gotcha moments and thus is one of the popular source of bugs.

To inherit from the base class, we can use the keyword `extend` and we can override any methods marked as `virtual`, as shown in the example below:

```SystemVerilog
class Vehicle;
    function int num_wheels();
        return 4;
    endfunction

    virtual function int num_seats();
        return 2;
    endfunction

endclass

class Car extends Vehicle;
    function int num_seats();
        return 4;
    endfunction
endclass

module top;

initial begin
    Car car;
    car = new();
    // we will get
    // num of seats: 4
    $display("num of seats: %0d", car.num_seats());
end

endmodule
```

In the code example, we first declare the base class `Vehicle`, and then inherit it with `Car` class. Notice that `num_seats` is marked as `virtual`, allowing it to be overridden by child classes. 

Abstract class and abstract methods are also supported in SystemVerilog and their semantics is identical to most OOP languages:
1. Users cannot directly instantiate an abstract class - a compiler error will be issued.
2. Users cannot inherit an abstract class without fully implement abstract methods.

To declare the class as an abstract class, we can declare the class as `virtual class` using the keyword `virtual`. To indicate an abstract method, we can use a new keyword `pure` in addition to `virtual`, e.g. `pure virtual function`. Here is an example reusing the vehicle class.

```SystemVerilog
virtual class Vehicle;
    // abstract class can still offer implementations
    function int num_wheels();
        return 4;
    endfunction

    pure virtual function int num_seats();
endclass

class Car extends Vehicle;
    function int num_seats();
        return 4;
    endfunction
endclass

module top;

initial begin
    Vehicle v;
    Car car;
    // the line before will trigger an error
    // v = new();
    car = new();
    // we will get
    // num of seats: 4
    $display("num of seats: %0d", car.num_seats());
end

endmodule
```

## Polymorphism
One common gotcha is that if the base class method is *not* marked as `virtual` yet is still overridden in the child class, the base class's method will be called when used as base class, as shown below:

```SystemVerilog
class Bicycle extends Vehicle;
    function int num_wheels();
        return 2;
    endfunction
endclass

module top;

initial begin
    Bicycle bike;
    bike = new();
    Vehicle v = bike;
    // we will get
    // num of wheels: 4
    $display("num of wheels: %0d", v.num_wheels());
end

endmodule
```

## Class Parametrization


## Interface Class
